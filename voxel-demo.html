<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Babylon.js Voxel World Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            width: 100vw;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 14px;
            line-height: 1.8;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        #ui h2 {
            margin-bottom: 10px;
            color: #4fc3f7;
            font-size: 18px;
        }
        #ui .stat {
            color: #81c784;
            font-weight: bold;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }
        #crosshair::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            transform: translateY(-50%);
        }
        #crosshair::after {
            top: 0;
            left: 50%;
            width: 2px;
            height: 100%;
            transform: translateX(-50%);
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>

    <div id="ui">
        <h2>ðŸŽ® Voxel World Demo</h2>
        <div>FPS: <span id="fps" class="stat">60</span></div>
        <div>Chunks: <span id="chunks" class="stat">0</span></div>
        <div>Triangles: <span id="triangles" class="stat">0</span></div>
        <div style="margin-top: 10px; font-size: 12px; color: #ccc;">
            WASD - Move | Space - Jump | Mouse - Look
        </div>
    </div>

    <div id="crosshair"></div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script>
        'use strict';

        // ============================================================================
        // CONSTANTS & CONFIGURATION
        // ============================================================================

        const CONFIG = {
            CHUNK_SIZE: 16,           // 16x16x16 blocks per chunk
            WORLD_HEIGHT: 32,         // Max world height
            RENDER_DISTANCE: 3,       // Chunks to render in each direction
            BLOCK_SIZE: 1,            // Size of each block
            WATER_LEVEL: 8,           // Water height
            TREE_DENSITY: 0.02,       // Tree spawn probability
        };

        // Block types
        const BLOCK = {
            AIR: 0,
            GRASS: 1,
            DIRT: 2,
            STONE: 3,
            WATER: 4,
            WOOD: 5,
            LEAVES: 6,
        };

        // Block colors (for procedural texture)
        const BLOCK_COLORS = {
            [BLOCK.GRASS]: { r: 0.4, g: 0.8, b: 0.3 },
            [BLOCK.DIRT]: { r: 0.6, g: 0.4, b: 0.2 },
            [BLOCK.STONE]: { r: 0.5, g: 0.5, b: 0.5 },
            [BLOCK.WATER]: { r: 0.2, g: 0.5, b: 0.9 },
            [BLOCK.WOOD]: { r: 0.4, g: 0.25, b: 0.1 },
            [BLOCK.LEAVES]: { r: 0.2, g: 0.6, b: 0.2 },
        };

        // ============================================================================
        // NOISE GENERATION (Simplified Perlin-like noise)
        // ============================================================================

        class SimplexNoise {
            constructor(seed = 12345) {
                this.seed = seed;
                this.perm = this.generatePermutation(seed);
            }

            generatePermutation(seed) {
                const p = [];
                for (let i = 0; i < 256; i++) p[i] = i;

                // Shuffle using seed
                for (let i = 255; i > 0; i--) {
                    seed = (seed * 9301 + 49297) % 233280;
                    const j = Math.floor((seed / 233280) * (i + 1));
                    [p[i], p[j]] = [p[j], p[i]];
                }

                return [...p, ...p]; // Double it for overflow
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, y) {
                const h = hash & 3;
                const u = h < 2 ? x : y;
                const v = h < 2 ? y : x;
                return ((h & 1) ? -u : u) + ((h & 2) ? -2 * v : 2 * v);
            }

            noise2D(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;

                x -= Math.floor(x);
                y -= Math.floor(y);

                const u = this.fade(x);
                const v = this.fade(y);

                const a = this.perm[X] + Y;
                const b = this.perm[X + 1] + Y;

                return this.lerp(v,
                    this.lerp(u, this.grad(this.perm[a], x, y),
                                 this.grad(this.perm[b], x - 1, y)),
                    this.lerp(u, this.grad(this.perm[a + 1], x, y - 1),
                                 this.grad(this.perm[b + 1], x - 1, y - 1))
                );
            }

            octaveNoise2D(x, y, octaves = 4, persistence = 0.5) {
                let total = 0;
                let frequency = 1;
                let amplitude = 1;
                let maxValue = 0;

                for (let i = 0; i < octaves; i++) {
                    total += this.noise2D(x * frequency, y * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= 2;
                }

                return total / maxValue;
            }
        }

        // ============================================================================
        // CHUNK CLASS - Core voxel mesh generation with optimization
        // ============================================================================

        class Chunk {
            constructor(chunkX, chunkZ, scene, material, waterMaterial, noise) {
                this.chunkX = chunkX;
                this.chunkZ = chunkZ;
                this.scene = scene;
                this.material = material;
                this.waterMaterial = waterMaterial;
                this.noise = noise;

                // 3D array to store block data [x][y][z]
                this.blocks = new Array(CONFIG.CHUNK_SIZE);
                for (let x = 0; x < CONFIG.CHUNK_SIZE; x++) {
                    this.blocks[x] = new Array(CONFIG.WORLD_HEIGHT);
                    for (let y = 0; y < CONFIG.WORLD_HEIGHT; y++) {
                        this.blocks[x][y] = new Array(CONFIG.CHUNK_SIZE).fill(BLOCK.AIR);
                    }
                }

                this.mesh = null;
                this.waterMesh = null;
                this.generateTerrain();
                this.buildMesh();
            }

            // Generate terrain using noise
            generateTerrain() {
                const offsetX = this.chunkX * CONFIG.CHUNK_SIZE;
                const offsetZ = this.chunkZ * CONFIG.CHUNK_SIZE;

                for (let x = 0; x < CONFIG.CHUNK_SIZE; x++) {
                    for (let z = 0; z < CONFIG.CHUNK_SIZE; z++) {
                        const worldX = offsetX + x;
                        const worldZ = offsetZ + z;

                        // Generate height using multiple octaves of noise
                        const height = this.noise.octaveNoise2D(worldX * 0.02, worldZ * 0.02, 4, 0.5);
                        const terrainHeight = Math.floor(10 + height * 10);

                        // Fill blocks based on height
                        for (let y = 0; y < CONFIG.WORLD_HEIGHT; y++) {
                            if (y < terrainHeight - 3) {
                                this.blocks[x][y][z] = BLOCK.STONE;
                            } else if (y < terrainHeight - 1) {
                                this.blocks[x][y][z] = BLOCK.DIRT;
                            } else if (y < terrainHeight) {
                                this.blocks[x][y][z] = BLOCK.GRASS;
                            } else if (y < CONFIG.WATER_LEVEL) {
                                this.blocks[x][y][z] = BLOCK.WATER;
                            }
                        }
                    }
                }
            }

            // Check if a block is solid (not air or water)
            isSolid(x, y, z) {
                if (x < 0 || x >= CONFIG.CHUNK_SIZE ||
                    y < 0 || y >= CONFIG.WORLD_HEIGHT ||
                    z < 0 || z >= CONFIG.CHUNK_SIZE) {
                    return false; // Assume air outside chunk bounds
                }
                const block = this.blocks[x][y][z];
                return block !== BLOCK.AIR && block !== BLOCK.WATER;
            }

            // Check if block is water
            isWater(x, y, z) {
                if (x < 0 || x >= CONFIG.CHUNK_SIZE ||
                    y < 0 || y >= CONFIG.WORLD_HEIGHT ||
                    z < 0 || z >= CONFIG.CHUNK_SIZE) {
                    return false;
                }
                return this.blocks[x][y][z] === BLOCK.WATER;
            }

            // Build optimized mesh using VertexData with greedy meshing
            buildMesh() {
                const positions = [];
                const indices = [];
                const normals = [];
                const uvs = [];
                const colors = [];

                const waterPositions = [];
                const waterIndices = [];
                const waterNormals = [];
                const waterUvs = [];

                let vertexCount = 0;
                let waterVertexCount = 0;

                // Process each block
                for (let x = 0; x < CONFIG.CHUNK_SIZE; x++) {
                    for (let y = 0; y < CONFIG.WORLD_HEIGHT; y++) {
                        for (let z = 0; z < CONFIG.CHUNK_SIZE; z++) {
                            const blockType = this.blocks[x][y][z];

                            if (blockType === BLOCK.AIR) continue;

                            const isWaterBlock = blockType === BLOCK.WATER;
                            const worldX = x + this.chunkX * CONFIG.CHUNK_SIZE;
                            const worldZ = z + this.chunkZ * CONFIG.CHUNK_SIZE;

                            // Check each face and only add if visible
                            const faces = [
                                { dir: [0, 1, 0], check: [x, y + 1, z], verts: [[0,1,0], [1,1,0], [1,1,1], [0,1,1]], normal: [0,1,0] },  // Top
                                { dir: [0, -1, 0], check: [x, y - 1, z], verts: [[0,0,1], [1,0,1], [1,0,0], [0,0,0]], normal: [0,-1,0] }, // Bottom
                                { dir: [0, 0, 1], check: [x, y, z + 1], verts: [[0,0,1], [0,1,1], [1,1,1], [1,0,1]], normal: [0,0,1] },  // Front
                                { dir: [0, 0, -1], check: [x, y, z - 1], verts: [[1,0,0], [1,1,0], [0,1,0], [0,0,0]], normal: [0,0,-1] }, // Back
                                { dir: [1, 0, 0], check: [x + 1, y, z], verts: [[1,0,1], [1,1,1], [1,1,0], [1,0,0]], normal: [1,0,0] },  // Right
                                { dir: [-1, 0, 0], check: [x - 1, y, z], verts: [[0,0,0], [0,1,0], [0,1,1], [0,0,1]], normal: [-1,0,0] }, // Left
                            ];

                            for (const face of faces) {
                                // Face culling: skip if adjacent block is solid
                                if (isWaterBlock) {
                                    if (this.isWater(...face.check) || this.isSolid(...face.check)) continue;
                                } else {
                                    if (this.isSolid(...face.check)) continue;
                                }

                                const color = BLOCK_COLORS[blockType];
                                const baseIdx = isWaterBlock ? waterVertexCount : vertexCount;
                                const targetPositions = isWaterBlock ? waterPositions : positions;
                                const targetIndices = isWaterBlock ? waterIndices : indices;
                                const targetNormals = isWaterBlock ? waterNormals : normals;
                                const targetUvs = isWaterBlock ? waterUvs : uvs;

                                // Add 4 vertices for this face
                                for (const vert of face.verts) {
                                    targetPositions.push(
                                        (x + vert[0]) * CONFIG.BLOCK_SIZE,
                                        (y + vert[1]) * CONFIG.BLOCK_SIZE,
                                        (z + vert[2]) * CONFIG.BLOCK_SIZE
                                    );
                                    targetNormals.push(...face.normal);
                                    targetUvs.push(vert[0], vert[1]);

                                    if (!isWaterBlock) {
                                        colors.push(color.r, color.g, color.b, 1);
                                    }
                                }

                                // Add 2 triangles (6 indices) for this face
                                targetIndices.push(
                                    baseIdx, baseIdx + 1, baseIdx + 2,
                                    baseIdx, baseIdx + 2, baseIdx + 3
                                );

                                if (isWaterBlock) {
                                    waterVertexCount += 4;
                                } else {
                                    vertexCount += 4;
                                }
                            }
                        }
                    }
                }

                // Create solid blocks mesh
                if (positions.length > 0) {
                    const vertexData = new BABYLON.VertexData();
                    vertexData.positions = positions;
                    vertexData.indices = indices;
                    vertexData.normals = normals;
                    vertexData.uvs = uvs;
                    vertexData.colors = colors;

                    this.mesh = new BABYLON.Mesh(`chunk_${this.chunkX}_${this.chunkZ}`, this.scene);
                    vertexData.applyToMesh(this.mesh);
                    this.mesh.material = this.material;

                    // Enable collision
                    this.mesh.checkCollisions = true;
                }

                // Create water mesh
                if (waterPositions.length > 0) {
                    const waterVertexData = new BABYLON.VertexData();
                    waterVertexData.positions = waterPositions;
                    waterVertexData.indices = waterIndices;
                    waterVertexData.normals = waterNormals;
                    waterVertexData.uvs = waterUvs;

                    this.waterMesh = new BABYLON.Mesh(`water_${this.chunkX}_${this.chunkZ}`, this.scene);
                    waterVertexData.applyToMesh(this.waterMesh);
                    this.waterMesh.material = this.waterMaterial;
                }
            }

            // Get total triangle count
            getTriangleCount() {
                let count = 0;
                if (this.mesh) count += this.mesh.getTotalIndices() / 3;
                if (this.waterMesh) count += this.waterMesh.getTotalIndices() / 3;
                return count;
            }

            dispose() {
                if (this.mesh) this.mesh.dispose();
                if (this.waterMesh) this.waterMesh.dispose();
            }
        }

        // ============================================================================
        // WORLD MANAGER
        // ============================================================================

        class World {
            constructor(scene, material, waterMaterial, noise) {
                this.scene = scene;
                this.material = material;
                this.waterMaterial = waterMaterial;
                this.noise = noise;
                this.chunks = new Map();
            }

            getChunkKey(chunkX, chunkZ) {
                return `${chunkX},${chunkZ}`;
            }

            generateChunk(chunkX, chunkZ) {
                const key = this.getChunkKey(chunkX, chunkZ);
                if (this.chunks.has(key)) return;

                const chunk = new Chunk(chunkX, chunkZ, this.scene, this.material, this.waterMaterial, this.noise);
                this.chunks.set(key, chunk);
            }

            generateWorld() {
                const radius = CONFIG.RENDER_DISTANCE;
                for (let x = -radius; x <= radius; x++) {
                    for (let z = -radius; z <= radius; z++) {
                        this.generateChunk(x, z);
                    }
                }
            }

            getTotalTriangles() {
                let total = 0;
                this.chunks.forEach(chunk => {
                    total += chunk.getTriangleCount();
                });
                return total;
            }

            getChunkCount() {
                return this.chunks.size;
            }
        }

        // ============================================================================
        // TREE GENERATOR (Using Instancing)
        // ============================================================================

        class TreeGenerator {
            constructor(scene, world, noise) {
                this.scene = scene;
                this.world = world;
                this.noise = noise;
                this.treeInstances = [];

                this.createTreeTemplates();
                this.generateTrees();
            }

            createTreeTemplates() {
                // Tree trunk template
                this.trunkTemplate = BABYLON.MeshBuilder.CreateCylinder("trunk", {
                    height: 4,
                    diameter: 0.5,
                }, this.scene);
                this.trunkTemplate.position.y = 2;

                const trunkMat = new BABYLON.StandardMaterial("trunkMat", this.scene);
                trunkMat.diffuseColor = new BABYLON.Color3(0.4, 0.25, 0.1);
                this.trunkTemplate.material = trunkMat;
                this.trunkTemplate.isVisible = false;

                // Leaves template
                this.leavesTemplate = BABYLON.MeshBuilder.CreateBox("leaves", {
                    size: 3,
                }, this.scene);
                this.leavesTemplate.position.y = 5;

                const leavesMat = new BABYLON.StandardMaterial("leavesMat", this.scene);
                leavesMat.diffuseColor = new BABYLON.Color3(0.2, 0.7, 0.2);
                this.leavesTemplate.material = leavesMat;
                this.leavesTemplate.isVisible = false;

                // Enable shadows
                this.trunkTemplate.receiveShadows = true;
                this.leavesTemplate.receiveShadows = true;
            }

            generateTrees() {
                const radius = CONFIG.RENDER_DISTANCE;
                const trunkMatrices = [];
                const leavesMatrices = [];

                for (let cx = -radius; cx <= radius; cx++) {
                    for (let cz = -radius; cz <= radius; cz++) {
                        for (let i = 0; i < 3; i++) { // 3 trees per chunk
                            const x = cx * CONFIG.CHUNK_SIZE + Math.floor(Math.random() * CONFIG.CHUNK_SIZE);
                            const z = cz * CONFIG.CHUNK_SIZE + Math.floor(Math.random() * CONFIG.CHUNK_SIZE);

                            // Use noise to determine if tree should spawn
                            if (this.noise.noise2D(x * 0.1, z * 0.1) > 0.3) {
                                const height = this.noise.octaveNoise2D(x * 0.02, z * 0.02, 4, 0.5);
                                const y = Math.floor(10 + height * 10);

                                if (y > CONFIG.WATER_LEVEL) {
                                    const matrix = BABYLON.Matrix.Translation(x, y, z);
                                    trunkMatrices.push(matrix);
                                    leavesMatrices.push(matrix);
                                }
                            }
                        }
                    }
                }

                // Create thin instances
                if (trunkMatrices.length > 0) {
                    this.trunkTemplate.thinInstanceSetBuffer("matrix", trunkMatrices, 16, false);
                    this.trunkTemplate.isVisible = true;

                    this.leavesTemplate.thinInstanceSetBuffer("matrix", leavesMatrices, 16, false);
                    this.leavesTemplate.isVisible = true;
                }
            }
        }

        // ============================================================================
        // MAIN APPLICATION
        // ============================================================================

        class VoxelDemo {
            constructor() {
                this.canvas = document.getElementById('renderCanvas');
                this.engine = new BABYLON.Engine(this.canvas, true, {
                    preserveDrawingBuffer: true,
                    stencil: true,
                    antialias: true
                });

                this.scene = this.createScene();
                this.setupUI();

                // Start render loop
                this.engine.runRenderLoop(() => {
                    this.scene.render();
                    this.updateUI();
                });

                // Handle resize
                window.addEventListener('resize', () => {
                    this.engine.resize();
                });

                // Pointer lock for first-person controls
                this.canvas.addEventListener('click', () => {
                    this.canvas.requestPointerLock();
                });
            }

            createScene() {
                const scene = new BABYLON.Scene(this.engine);
                scene.clearColor = new BABYLON.Color3(0.5, 0.7, 1.0);
                scene.collisionsEnabled = true;
                scene.gravity = new BABYLON.Vector3(0, -0.5, 0);

                // Create noise generator
                this.noise = new SimplexNoise(42);

                // Camera setup with collision
                this.camera = new BABYLON.UniversalCamera("camera",
                    new BABYLON.Vector3(0, 20, -10), scene);
                this.camera.attachControl(this.canvas, true);
                this.camera.speed = 0.5;
                this.camera.angularSensibility = 1000;

                // Enable collision and gravity
                this.camera.checkCollisions = true;
                this.camera.applyGravity = true;
                this.camera.ellipsoid = new BABYLON.Vector3(0.5, 1, 0.5);

                // Jump
                this.camera.keysUp.push(87); // W
                this.camera.keysDown.push(83); // S
                this.camera.keysLeft.push(65); // A
                this.camera.keysRight.push(68); // D

                // Setup jump on space
                scene.onKeyboardObservable.add((kbInfo) => {
                    if (kbInfo.type === BABYLON.KeyboardEventTypes.KEYDOWN && kbInfo.event.code === 'Space') {
                        // Simple jump (modify velocity)
                        this.camera.position.y += 0.5;
                    }
                });

                // Lighting
                const hemiLight = new BABYLON.HemisphericLight("hemiLight",
                    new BABYLON.Vector3(0, 1, 0), scene);
                hemiLight.intensity = 0.6;
                hemiLight.groundColor = new BABYLON.Color3(0.3, 0.3, 0.5);

                const sunLight = new BABYLON.DirectionalLight("sunLight",
                    new BABYLON.Vector3(-1, -2, -1), scene);
                sunLight.position = new BABYLON.Vector3(20, 40, 20);
                sunLight.intensity = 0.8;
                sunLight.diffuse = new BABYLON.Color3(1, 0.95, 0.8);

                // Shadow generator
                this.shadowGenerator = new BABYLON.ShadowGenerator(2048, sunLight);
                this.shadowGenerator.useBlurExponentialShadowMap = true;
                this.shadowGenerator.blurScale = 2;

                // Create materials
                this.createMaterials(scene);

                // Generate world
                this.world = new World(scene, this.terrainMaterial, this.waterMaterial, this.noise);
                this.world.generateWorld();

                // Generate trees (with instancing)
                this.treeGenerator = new TreeGenerator(scene, this.world, this.noise);

                // Add trees to shadow casters
                this.shadowGenerator.addShadowCaster(this.treeGenerator.trunkTemplate);
                this.shadowGenerator.addShadowCaster(this.treeGenerator.leavesTemplate);

                // Enable fog for atmosphere
                scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
                scene.fogDensity = 0.01;
                scene.fogColor = new BABYLON.Color3(0.5, 0.7, 1.0);

                return scene;
            }

            createMaterials(scene) {
                // Terrain material (uses vertex colors)
                this.terrainMaterial = new BABYLON.StandardMaterial("terrainMat", scene);
                this.terrainMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
                this.terrainMaterial.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                this.terrainMaterial.emissiveColor = new BABYLON.Color3(0.05, 0.05, 0.05);

                // Create procedural texture
                const proceduralTexture = new BABYLON.DynamicTexture("procTex", 256, scene);
                const ctx = proceduralTexture.getContext();
                const imageData = ctx.createImageData(256, 256);

                // Generate noise texture
                for (let y = 0; y < 256; y++) {
                    for (let x = 0; x < 256; x++) {
                        const idx = (y * 256 + x) * 4;
                        const noise = this.noise.octaveNoise2D(x * 0.05, y * 0.05, 3, 0.5);
                        const value = Math.floor((noise + 1) * 0.5 * 255);
                        imageData.data[idx] = value;
                        imageData.data[idx + 1] = value;
                        imageData.data[idx + 2] = value;
                        imageData.data[idx + 3] = 255;
                    }
                }
                ctx.putImageData(imageData, 0, 0);
                proceduralTexture.update();

                this.terrainMaterial.ambientTexture = proceduralTexture;
                this.terrainMaterial.useVertexColors = true;

                // Water shader material
                this.waterMaterial = new BABYLON.ShaderMaterial("waterShader", scene, {
                    vertex: "custom",
                    fragment: "custom",
                }, {
                    attributes: ["position", "normal", "uv"],
                    uniforms: ["world", "worldView", "worldViewProjection", "view", "projection", "time"],
                });

                // Water shader code
                BABYLON.Effect.ShadersStore["customVertexShader"] = `
                    precision highp float;

                    attribute vec3 position;
                    attribute vec3 normal;
                    attribute vec2 uv;

                    uniform mat4 worldViewProjection;
                    uniform mat4 world;
                    uniform float time;

                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec2 vUV;

                    void main(void) {
                        vec3 pos = position;

                        // Animated waves
                        pos.y += sin(pos.x * 2.0 + time) * 0.05;
                        pos.y += cos(pos.z * 2.0 + time * 1.5) * 0.05;

                        gl_Position = worldViewProjection * vec4(pos, 1.0);

                        vPosition = vec3(world * vec4(position, 1.0));
                        vNormal = normalize(vec3(world * vec4(normal, 0.0)));
                        vUV = uv;
                    }
                `;

                BABYLON.Effect.ShadersStore["customFragmentShader"] = `
                    precision highp float;

                    uniform float time;

                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec2 vUV;

                    void main(void) {
                        // Animated water color
                        vec3 waterColor = vec3(0.2, 0.5, 0.9);
                        float wave = sin(vPosition.x * 3.0 + time) * cos(vPosition.z * 3.0 + time * 1.2);
                        waterColor += wave * 0.1;

                        // Transparency with fresnel-like effect
                        vec3 viewDir = normalize(vec3(0.0, 1.0, 0.0) - vPosition);
                        float fresnel = pow(1.0 - max(dot(viewDir, vNormal), 0.0), 2.0);
                        float alpha = 0.6 + fresnel * 0.3;

                        gl_FragColor = vec4(waterColor, alpha);
                    }
                `;

                // Set water material properties
                this.waterMaterial.setFloat("time", 0);
                this.waterMaterial.backFaceCulling = false;
                this.waterMaterial.alpha = 0.8;
                this.waterMaterial.alphaMode = BABYLON.Engine.ALPHA_COMBINE;

                // Animate water
                scene.registerBeforeRender(() => {
                    this.waterMaterial.setFloat("time", performance.now() * 0.001);
                });
            }

            setupUI() {
                this.fpsElement = document.getElementById('fps');
                this.chunksElement = document.getElementById('chunks');
                this.trianglesElement = document.getElementById('triangles');
            }

            updateUI() {
                this.fpsElement.textContent = Math.round(this.engine.getFps());
                this.chunksElement.textContent = this.world.getChunkCount();
                this.trianglesElement.textContent = Math.round(this.world.getTotalTriangles()).toLocaleString();
            }
        }

        // ============================================================================
        // START APPLICATION
        // ============================================================================

        window.addEventListener('DOMContentLoaded', () => {
            new VoxelDemo();
        });
    </script>
</body>
</html>